import {HttpClient} from '@angular/common/http';
import {Injectable} from '@angular/core';
import {MatSnackBar} from '@angular/material/snack-bar';
import * as moment from 'moment';
import {BehaviorSubject, Observable} from 'rxjs';
import {SettingsService} from './settings.service';

@Injectable({
  providedIn: 'root'
})
export class AmbientLightService {

  /**
   * Method for retrieving the current dark-mode status
   */
  get darkMode(): Observable<boolean> {
    return this.isDark.asObservable();
  }
  private location: Position;
  private sunrise: Date;
  private sunset: Date;
  private isDark: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  private enableAdaption = false;

  constructor(private http: HttpClient,
              private snackBar: MatSnackBar,
              private settings: SettingsService) {
    // get geolocation of current device
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition((position: Position) => {
          if (position) {
            this.location = position;
            this.getSunsetSunrise(position.coords);
          }
        },
        (error: PositionError) => {
          this.snackBar.open('Geolocation Access not granted, Ambient Light not available.');
          console.log(error);
        });
    } else {
      alert('Geolocation is not supported by your browser.');
    }

    // set timer for calcDarkMode, to periodically get checked if the dark-mode is necessary, if dark-mode is being
    // subscribed on
    // timer(0, 60000)
    //   .subscribe(() => {
    //     this.calcDarkMode();
    //   });
  }

  /**
   * Method for forcing a dark-mode setting. This overwrites the internal dark-mode settings.
   */
  public setDarkMode(value: boolean): void {
      if (this.enableAdaption === true) {
        this.isDark.next(value);
      }
  }

  /**
   * Currently calculates, if the dark-mode has to be applied based on the current time. In the future, other custom
   * options or preferences are possible.
   */
  public calcDarkMode(): void {
    const now = new Date();
    if (this.enableAdaption === true) {
      // compare current time with sunrise/ sunset time
      if ((now < this.sunrise) || (now > this.sunset)) {
        this.isDark.next(true);
      } else {
        this.isDark.next(false);
      }
    }
  }

  /**
   * Method for enabling/ disabling the ambient light adaption globally
   * @param state
   */
  public enableAmbientLightAdaption(state: boolean): void {
    this.enableAdaption = state;
    if (state === false) {
      this.isDark.next(false);
    }
  }

  public getAmbientAdaptionEnabled(): boolean {
    return this.enableAdaption;
  }

  /**
   * calculates the sunrise & sunset time based on the coordinates generated by geolocation coordinates
   * @param coords coordinates from geolocation call
   */
  private getSunsetSunrise(coords: Coordinates) {
    this.http.get('https://api.sunrise-sunset.org/json?lat=' + coords.latitude + '&lng=' + coords.longitude +
      '&date=today').subscribe((json: any ) => {
      this.sunrise = new Date(moment(json.results.sunrise, 'LTS').format());
      this.sunset = new Date(moment(json.results.sunset, 'LTS').format());

      // correct for timezone Berlin
      moment(this.sunrise).add(1, 'h');
      moment(this.sunset).add(1, 'h');

      // correct for daylight saving time
      if (moment(this.sunrise).isDST()) {
        moment(this.sunrise).add(1, 'h');
      }
      if (moment(this.sunset).isDST()) {
        moment(this.sunset).add(1, 'h');
      }

      this.calcDarkMode();
    });
  }

}
